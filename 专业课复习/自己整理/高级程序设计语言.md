## 符号`::和：`的作用和区别

- `::`是作用域运算符，A::B表示作用域A中的-名称B，A可以是名字空间、类、结构；

- - 类作用域操作符
    “::”指明了成员函数所属的类。如：M::f(s)就表示f(s)是类M的成员函数。 *作用域，如果想在类的外部引用静态成员函数，或在类的外部定义成员函数都要用到。使用命名空间里的类型或函数也要用到（如：std::cout, std::cin, std::string 等等）*

- - 表示“域操作符” 例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时， 就要写成void A::f()，表示这个f()函数是类A的成员函数。
  - 表示引用成员函数及变量，作用域成员运算符 例：System::Math::Sqrt() 相当于System.Math.Sqrt()

完整内容：

[C++中::和:， .和->的作用和区别](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/whZhBGB6Ls5HM3IHZKHcNw)



~~~cpp
class Test{
            public:
                Test();
                static void print() 
                {
                    std::cout<<"Test"<<endl; //命名空间时使用::
                    }
            private:
                int a;
                    };
            Test::Test() : a(1)   //成员函数定义时使用::
            {}
            Test::get();  //使用静态成员函数时用::
        ```

~~~

- ```：```一般用来表示继承；表示机构内位域的定义（即该变量占几个bit空间）

```C++
typedef struct _XXX{

    unsigned char a:4;

    unsigned char c;

};XXX
```

1. 在构造函数后面，冒号起分割作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型。

```
构造函数，就是与类同名的函数，它与普通函数的区别在于，它没有返回类型。在构造函数后面紧跟着冒号加初始化列表，各初始化变量之间以逗号(,)隔开。例如：
class myClass
{
public :
    myClass();// 构造函数，无返回类型，可以有参数列表，这里省去
    ~myClass();// 析构函数
    int a;
    const int b;
}

myClass::myClass():a(1),b(1)// 初始化列表
{
}
```

关于“：”冒号的用法的说明： 

1.初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。 在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显：const 类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，如：

```cpp
myClass::myClass（）
{
    a = 1;// 没错，效果相当于在初始化列表中进行初始化
    b = 1;// 出错，const变量不能进行赋值操作；
}

```

2. 初始化的顺序与成员变量声名的顺序相同。
  先看一下下面的程序：

  ```
  myClass::myClass():b(1),a(b)
  {
  }
  ```

这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。

3) public:和private:后面的冒号，表示后面定义的所有成员都是公有或私有的，直到下个"public:”或"private:”出现为止。"private:"为默认处理。

4) 类名冒号后面的是用来定义类的继承。

```cpp
class 派生类名 : 继承方式 基类名

{

派生类的成员

};
这里的冒号起到的就是声名基类的作用，在基类类名前面可以加public/private/protected等标签，用于标识继承的类型，也可以省略， 省略的话，用class定义的类默认为private，用struct定义的类默认为public。
与初始化列表一样的，这里也可以声名多个基类，各基类之间用逗号(,)隔开。
```

5) 条件语句(? :) 与?构成条件语句，作用相当于if else，如下；

```cpp
int a,b,c;
a=3;
b=2;
c=a>b?a:b;// 如果a>b成立，则反a赋给c，否则把b赋给c
条件语句的结构为：
条件表达式?表达式1:表达式2
当条件表达式为true时，表达式的值为表达式1的值，否则为表达式2的值。

注意：
1）?:可以嵌套，但不推荐使用（难懂），例如：
int max = i>j ? i>k ? i : k : j>k ? j : k;
2）?:具有很低的优先级，例如：
int i = 3;
int j = 2;
cout << i>j?i:j;// 出错，<<比>具有更高的优先级，执行顺序为 ((cout<<i)>j)?i:j,相当于是比较cout<<i与j的大小，然后根据比较结果决定表达式值为i或j，这 显然要出错的，cout<<i的值是cout，不能跟整型数j进行比较。
cout << (i>j)?i:j;//输出1或0，相当于(cout<<(i>j))作为判决条件，来决定表达式的值为i或j，而 cout<<(i>j)，i>j则输出1否则0，然后再将(cout<<(i>j))作为？：的条件，如果 cout正确执行则为1（true），否则为0（false），以此决定表达式值为i或j
cout <<(i>j?i:j);//i>j则输出i，否则输出j，表达式值为true如果cout正确执行，否则为false
```

6) 语句标签 通常跟goto配合使用，如：

```cpp
step1: a = f1();
....
goto step1;
```

这种作法也不是很推荐，原因在于它破坏了语句的顺序执行; 

7.switch语句中case后。

## 符号`.和->`的作用和区别

- A.B则A为对象或者结构体； 点号（.）：左边必须为实体。
- A->B则A为指针，->是成员提取，A->B是提取A中的成员B，A只能是指向类、结构、联合的指针； 箭头（->）：左边必须为指针；